{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport ConnectyCube from 'connectycube';\nimport Dialog from '../models/dialogs';\nimport { fetchDialogs, sortDialogs, updateDialog, addNewDialog } from '../actions/dialogs';\nimport { pushMessage, setMessages, lazyFetchMessages, updateMessages } from '../actions/messages';\nimport { preparationAttachment } from '../helpers/file';\nimport { selectedDialog } from '../actions/selectedDialog';\nimport { fetchUsers } from '../actions/users';\nimport store from '../store';\nimport { Message, FakeMessage } from '../models/message';\nimport UserModel from '../models/user';\nimport { DIALOG_TYPE } from '../helpers/constants';\nimport { STATUS_DELIVERED, STATUS_READ, STATUS_SENT, GROUP_CHAT_ALERT_TYPE } from '../models/message';\n\nclass ChatService {\n  constructor() {\n    _defineProperty(this, \"getMoreMessages\", async dialog => {\n      const currentMessages = this.getMessagesByDialogId(dialog.id);\n      const lastMessageDate = currentMessages[0];\n      const updateObj = Object.assign(dialog, {\n        last_messages_for_fetch: lastMessageDate.date_sent\n      });\n      const filter = {\n        chat_dialog_id: dialog.id,\n        date_sent: {\n          lt: lastMessageDate.date_sent\n        },\n        sort_desc: 'date_sent'\n      };\n      const moreHistoryFromServer = await ConnectyCube.chat.message.list(filter);\n      const messages = [];\n      moreHistoryFromServer.items.forEach(elem => {\n        if (!elem.group_chat_alert_type) {\n          messages.push(new Message(elem, this.currentUser.id));\n        }\n      });\n      store.dispatch(updateDialog(updateObj));\n      const amountMessages = store.dispatch(lazyFetchMessages(dialog.id, messages));\n      return amountMessages.history.length;\n    });\n\n    _defineProperty(this, \"sendMsgChatAlertOnCreate\", async (dialog, message, alertType) => {\n      const date = Math.floor(Date.now() / 1000);\n      const recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(elem => elem != this.currentUser.id) : dialog.xmpp_room_jid;\n      const messageExtensions = {\n        date_sent: date,\n        save_to_history: 1,\n        dialog_id: dialog.id,\n        group_chat_alert_type: alertType,\n        sender_id: this.currentUser.id\n      };\n      const msg = {\n        type: !dialog.xmpp_room_jid ? 'chat' : 'groupchat',\n        body: message,\n        extension: messageExtensions\n      };\n      ConnectyCube.chat.send(recipient_id, msg);\n    });\n\n    _defineProperty(this, \"updateDialogsUnreadMessagesCount\", dialog => {\n      const updateObj = Object.assign(dialog, {\n        unread_messages_count: 0\n      });\n      store.dispatch(updateDialog(updateObj));\n      return true;\n    });\n  }\n\n  setUpListeners() {\n    ConnectyCube.chat.onMessageListener = this.onMessageListener.bind(this);\n    ConnectyCube.chat.onSentMessageCallback = this.onSentMessageListener.bind(this);\n    ConnectyCube.chat.onDeliveredStatusListener = this.onDeliveredStatus.bind(this);\n    ConnectyCube.chat.onReadStatusListener = this.onReadStatus.bind(this);\n  }\n\n  async fetchDialogsFromServer() {\n    if (store.getState().dialogs.length !== 0) {\n      return store.getState().dialogs;\n    }\n\n    console.log('in fetch');\n    const dialogsFromServer = await ConnectyCube.chat.dialog.list(); // const currentUserId = this.currentUser\n    // let privatChatIdsUser = []\n\n    const dialogs = dialogsFromServer.items.map(elem => {\n      // if (elem.type === DIALOG_TYPE.PRIVATE) {\n      //   elem.occupants_ids.forEach(elem => {\n      //     elem !== currentUserId.id && privatChatIdsUser.push(elem)\n      //   })\n      // }\n      return new Dialog(elem);\n    }); // if (privatChatIdsUser.length !== 0) {\n    //   const usersInfo = await this.getUsersList(privatChatIdsUser)\n    //   store.dispatch(fetchUsers(usersInfo))\n    // }\n\n    store.dispatch(fetchDialogs(dialogs));\n    return store.getState().dialogs;\n  }\n\n  async getMessages(dialog) {\n    const isAlredyUpdate = this.getMessagesByDialogId(dialog.id);\n    let amountMessages = null; // If the first entry into the chat\n\n    if (!dialog.isAlreadyMessageFetch || dialog.unread_messages_count > 0 && !dialog.isAlreadyMessageFetch) {\n      const historyFromServer = await ConnectyCube.chat.message.list({\n        chat_dialog_id: dialog.id,\n        sort_desc: 'date_sent'\n      });\n      const messages = [];\n      historyFromServer.items.forEach(elem => {\n        if (!elem.group_chat_alert_type) {\n          messages.push(new Message(elem, this.currentUser.id));\n        }\n      });\n      const newObj = Object.assign(dialog, {\n        isAlreadyMessageFetch: true\n      });\n      this.updateDialogsUnreadMessagesCount(newObj);\n      store.dispatch(setMessages(dialog.id, messages));\n      amountMessages = messages.length;\n    } else {\n      // If the second entry into the chat\n      if (dialog.unread_messages_count > 0) {\n        const messages = this.getMessagesByDialogId(dialog.id);\n        const firstUnreadMsg = messages[dialog.unread_messages_count - 1];\n        this.readAllMessages(dialog.id);\n        await this.sendReadStatus(firstUnreadMsg.id, firstUnreadMsg.sender_id, firstUnreadMsg.dialog_id);\n        this.updateDialogsUnreadMessagesCount(dialog);\n      }\n\n      amountMessages = isAlredyUpdate.length;\n    }\n\n    return amountMessages;\n  } // Message loading if more than 100\n\n\n  async sendMessage(dialog, messageText, attachments = false, scrollToBottom) {\n    const user = this.currentUser;\n    const text = messageText.trim();\n    const date = Math.floor(Date.now() / 1000);\n    const recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(elem => elem != user.id) : dialog.xmpp_room_jid;\n    let msg = {\n      type: dialog.xmpp_type,\n      body: text,\n      extension: {\n        save_to_history: 1,\n        dialog_id: dialog.id,\n        sender_id: user.id,\n        date_sent: date\n      } // markable: 1\n\n    };\n    msg.id = this.messageUniqueId; // If send message as Attachment\n\n    if (attachments) {\n      return this.sendMessageAsAttachment(dialog, recipient_id, msg, attachments, scrollToBottom);\n    }\n\n    const message = new FakeMessage(msg);\n    const newObjFreez = Object.freeze(message);\n    await store.dispatch(pushMessage(newObjFreez, dialog.id));\n    scrollToBottom();\n    ConnectyCube.chat.send(recipient_id, msg);\n    store.dispatch(sortDialogs(newObjFreez));\n  }\n\n  sendChatAlertOnCreate(dialog) {\n    const message = 'Group is created';\n    this.sendMsgChatAlertOnCreate(dialog, message, GROUP_CHAT_ALERT_TYPE.CREATE);\n  }\n\n  async sendMessageAsAttachment(dialog, recipient_id, msg, attachments, scrollToBottom) {\n    //create fake data for render img\n    const url = URL.createObjectURL(attachments.file);\n    msg.extension.attachments = [{\n      url\n    }];\n    msg.body = 'Image attachment';\n    const message = new FakeMessage(msg);\n    await store.dispatch(pushMessage(message, dialog.id));\n    scrollToBottom(); // create real data for attachment\n\n    const response = await this.uploadPhoto(attachments);\n    const newObjAttach = preparationAttachment(response);\n    msg.extension.attachments = [newObjAttach];\n    await ConnectyCube.chat.send(recipient_id, msg);\n    store.dispatch(sortDialogs(message));\n    return;\n  }\n\n  async createPrivateDialog(userId) {\n    const dialogs = store.getState().dialogs;\n    let dialog = null;\n    dialogs.forEach(elem => {\n      if (elem.type === DIALOG_TYPE.PRIVATE && elem.occupants_ids.find(elem => elem === userId)) {\n        dialog = elem;\n      }\n    });\n\n    if (!dialog) {\n      const params = {\n        type: DIALOG_TYPE.PRIVATE,\n        occupants_ids: userId\n      };\n      const response = await ConnectyCube.chat.dialog.create(params);\n      dialog = new Dialog(response);\n\n      if (this.getUserFromReduxById(userId)) {\n        store.dispatch(addNewDialog(dialog));\n        return dialog;\n      } else {\n        const usersInfo = await this.getUserFromServerById(userId);\n        usersInfo.user = new UserModel(usersInfo.user);\n        store.dispatch(fetchUsers([usersInfo.user]));\n        store.dispatch(addNewDialog(dialog));\n        return dialog;\n      }\n    } // If the user is already in the Redux\n\n\n    if (this.getUserFromReduxById(userId)) {\n      return dialog;\n    } else {\n      const usersInfo = await this.getUserFromServerById(userId);\n      usersInfo.user = new UserModel(usersInfo.user);\n      store.dispatch(fetchUsers([usersInfo.user]));\n      return dialog;\n    }\n  }\n\n  async createPublicDialog(occupants_ids, groupName, img) {\n    const currentUser = this.currentUser;\n    occupants_ids.unshift(currentUser.id);\n    const params = {\n      type: DIALOG_TYPE.GROUP,\n      occupants_ids,\n      name: groupName\n    };\n    const image = img ? await this.uploadPhoto(img) : null;\n\n    if (image) {\n      params.photo = image.uid;\n    }\n\n    const dialog = await ConnectyCube.chat.dialog.create(params);\n    const newDialog = new Dialog(dialog);\n    store.dispatch(addNewDialog(newDialog));\n    return newDialog;\n  }\n\n  async readAllMessages(dialogId) {\n    return ConnectyCube.chat.message.update(null, {\n      chat_dialog_id: dialogId,\n      read: 1\n    });\n  }\n\n  async readMessage(messageId, dialogId) {\n    this.onReadStatus(messageId, dialogId);\n    return ConnectyCube.chat.message.update(null, {\n      chat_dialog_id: dialogId,\n      read: 1\n    });\n  }\n\n  async onMessageListener(senderId, msg) {\n    var _this$getSelectedDial;\n\n    const message = new Message(msg);\n    const user = this.currentUser;\n    const dialog = (_this$getSelectedDial = this.getSelectedDialog()) === null || _this$getSelectedDial === void 0 ? void 0 : _this$getSelectedDial.id; // If group chat alet\n\n    if (msg.extension.group_chat_alert_type) {\n      const dialogsFromServer = await ConnectyCube.chat.dialog.list();\n      const dialogs = dialogsFromServer.items.map(elem => {\n        return new Dialog(elem);\n      });\n      store.dispatch(fetchDialogs(dialogs));\n      return;\n    }\n\n    if (senderId !== user.id) {\n      if (dialog === message.dialog_id) {\n        store.dispatch(sortDialogs(message));\n        this.readMessage(message.id, message.dialog_id);\n        this.sendReadStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id);\n      } else {\n        this.sendDeliveredStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id);\n        store.dispatch(sortDialogs(message, true));\n      }\n\n      store.dispatch(pushMessage(message, message.dialog_id));\n    }\n  } // ConnectyCube listeners\n\n\n  onSentMessageListener(failedMessage, msg) {\n    console.warn('onSentMessageListener');\n\n    if (failedMessage || msg.extension.group_chat_alert_type) {\n      return;\n    }\n\n    store.dispatch(updateMessages(msg.extension.dialog_id, msg.id, {\n      send_state: STATUS_SENT\n    }));\n  }\n\n  onDeliveredStatus(messageId, dialogId, userId) {\n    console.warn('onDeliveredStatus', messageId);\n    store.dispatch(updateMessages(dialogId, messageId, {\n      send_state: STATUS_DELIVERED\n    }));\n  }\n\n  onReadStatus(messageId, dialogId, userId) {\n    console.warn('onReadStatus', messageId);\n    store.dispatch(updateMessages(dialogId, messageId, {\n      send_state: STATUS_READ\n    }));\n  }\n\n  sendReadStatus(messageId, userId, dialogId) {\n    ConnectyCube.chat.sendReadStatus({\n      messageId,\n      userId,\n      dialogId\n    });\n  }\n\n  sendDeliveredStatus(messageId, userId, dialogId) {\n    ConnectyCube.chat.sendDeliveredStatus({\n      messageId,\n      userId,\n      dialogId\n    });\n  }\n\n  async getUsersList(ids) {\n    const usersList = await ConnectyCube.users.get({\n      per_page: 100,\n      filter: {\n        field: 'id',\n        param: 'in',\n        value: ids\n      }\n    });\n    return usersList.items.map(elem => {\n      return new UserModel(elem.user);\n    });\n  }\n\n  async getUserFromServerById(id) {\n    return ConnectyCube.users.get(id);\n  }\n\n  setSelectDialog(dialog) {\n    store.dispatch(selectedDialog(dialog));\n  }\n\n  getSelectedDialog() {\n    return store.getState().selectedDialog;\n  }\n\n  getDialogById(dialogId) {\n    return store.getState().dialogs.find(elem => elem.id === dialogId);\n  }\n\n  getMessagesByDialogId(dialogId) {\n    const result = store.getState().messages;\n    return result[dialogId];\n  }\n\n  async uploadPhoto(file) {\n    return ConnectyCube.storage.createAndUpload(file);\n  }\n\n  get currentUser() {\n    return store.getState().currentUser.user;\n  }\n\n  getUserFromReduxById(id) {\n    return store.getState().users[id];\n  }\n\n  get messageUniqueId() {\n    return ConnectyCube.chat.helpers.getBsonObjectId();\n  }\n\n}\n\nconst chatService = new ChatService();\nObject.freeze(chatService);\nexport default chatService;","map":{"version":3,"sources":["C:/Users/91911/Downloads/frontend/src/redux/services/chat-service.js"],"names":["ConnectyCube","Dialog","fetchDialogs","sortDialogs","updateDialog","addNewDialog","pushMessage","setMessages","lazyFetchMessages","updateMessages","preparationAttachment","selectedDialog","fetchUsers","store","Message","FakeMessage","UserModel","DIALOG_TYPE","STATUS_DELIVERED","STATUS_READ","STATUS_SENT","GROUP_CHAT_ALERT_TYPE","ChatService","dialog","currentMessages","getMessagesByDialogId","id","lastMessageDate","updateObj","Object","assign","last_messages_for_fetch","date_sent","filter","chat_dialog_id","lt","sort_desc","moreHistoryFromServer","chat","message","list","messages","items","forEach","elem","group_chat_alert_type","push","currentUser","dispatch","amountMessages","history","length","alertType","date","Math","floor","Date","now","recipient_id","type","PRIVATE","occupants_ids","find","xmpp_room_jid","messageExtensions","save_to_history","dialog_id","sender_id","msg","body","extension","send","unread_messages_count","setUpListeners","onMessageListener","bind","onSentMessageCallback","onSentMessageListener","onDeliveredStatusListener","onDeliveredStatus","onReadStatusListener","onReadStatus","fetchDialogsFromServer","getState","dialogs","console","log","dialogsFromServer","map","getMessages","isAlredyUpdate","isAlreadyMessageFetch","historyFromServer","newObj","updateDialogsUnreadMessagesCount","firstUnreadMsg","readAllMessages","sendReadStatus","sendMessage","messageText","attachments","scrollToBottom","user","text","trim","xmpp_type","messageUniqueId","sendMessageAsAttachment","newObjFreez","freeze","sendChatAlertOnCreate","sendMsgChatAlertOnCreate","CREATE","url","URL","createObjectURL","file","response","uploadPhoto","newObjAttach","createPrivateDialog","userId","params","create","getUserFromReduxById","usersInfo","getUserFromServerById","createPublicDialog","groupName","img","unshift","GROUP","name","image","photo","uid","newDialog","dialogId","update","read","readMessage","messageId","senderId","getSelectedDialog","message_id","sendDeliveredStatus","failedMessage","warn","send_state","getUsersList","ids","usersList","users","get","per_page","field","param","value","setSelectDialog","getDialogById","result","storage","createAndUpload","helpers","getBsonObjectId","chatService"],"mappings":"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","sourcesContent":["import ConnectyCube from 'connectycube'\nimport Dialog from '../models/dialogs'\nimport {\n  fetchDialogs,\n  sortDialogs,\n  updateDialog,\n  addNewDialog,\n} from '../actions/dialogs'\nimport {\n  pushMessage,\n  setMessages,\n  lazyFetchMessages,\n  updateMessages,\n} from '../actions/messages'\nimport { preparationAttachment } from '../helpers/file'\nimport { selectedDialog } from '../actions/selectedDialog'\nimport { fetchUsers } from '../actions/users'\nimport store from '../store'\nimport { Message, FakeMessage } from '../models/message'\nimport UserModel from '../models/user'\nimport { DIALOG_TYPE } from '../helpers/constants'\nimport {\n  STATUS_DELIVERED,\n  STATUS_READ,\n  STATUS_SENT,\n  GROUP_CHAT_ALERT_TYPE\n} from '../models/message'\n\nclass ChatService {\n\n  setUpListeners() {\n    ConnectyCube.chat.onMessageListener = this.onMessageListener.bind(this)\n    ConnectyCube.chat.onSentMessageCallback = this.onSentMessageListener.bind(this)\n    ConnectyCube.chat.onDeliveredStatusListener = this.onDeliveredStatus.bind(this)\n    ConnectyCube.chat.onReadStatusListener = this.onReadStatus.bind(this)\n  }\n\n  async fetchDialogsFromServer() {\n    if (store.getState().dialogs.length !== 0) {\n      return store.getState().dialogs\n    }\n\n    console.log('in fetch')\n   const dialogsFromServer =  await ConnectyCube.chat.dialog.list()\n    // const currentUserId = this.currentUser\n    // let privatChatIdsUser = []\n\n    const dialogs = dialogsFromServer.items.map(elem => {\n      // if (elem.type === DIALOG_TYPE.PRIVATE) {\n      //   elem.occupants_ids.forEach(elem => {\n      //     elem !== currentUserId.id && privatChatIdsUser.push(elem)\n      //   })\n      // }\n      return new Dialog(elem)\n    })\n\n    // if (privatChatIdsUser.length !== 0) {\n    //   const usersInfo = await this.getUsersList(privatChatIdsUser)\n    //   store.dispatch(fetchUsers(usersInfo))\n    // }\n\n    store.dispatch(fetchDialogs(dialogs))\n    return store.getState().dialogs\n  }\n\n  async getMessages(dialog) {\n    const isAlredyUpdate = this.getMessagesByDialogId(dialog.id)\n    let amountMessages = null\n\n    // If the first entry into the chat\n    if (!dialog.isAlreadyMessageFetch || dialog.unread_messages_count > 0 && !dialog.isAlreadyMessageFetch) {\n      const historyFromServer = await ConnectyCube.chat.message.list({\n        chat_dialog_id: dialog.id,\n        sort_desc: 'date_sent'\n      })\n\n      const messages = []\n      historyFromServer.items.forEach(elem => {\n        if (!elem.group_chat_alert_type) {\n          messages.push(new Message(elem, this.currentUser.id))\n        }\n      })\n\n      const newObj = Object.assign(dialog, { isAlreadyMessageFetch: true })\n      this.updateDialogsUnreadMessagesCount(newObj)\n      store.dispatch(setMessages(dialog.id, messages))\n      amountMessages = messages.length\n    } else {\n      // If the second entry into the chat\n      if (dialog.unread_messages_count > 0) {\n        const messages = this.getMessagesByDialogId(dialog.id)\n        const firstUnreadMsg = messages[dialog.unread_messages_count - 1]\n        this.readAllMessages(dialog.id)\n        await this.sendReadStatus(firstUnreadMsg.id, firstUnreadMsg.sender_id, firstUnreadMsg.dialog_id)\n        this.updateDialogsUnreadMessagesCount(dialog)\n      }\n      amountMessages = isAlredyUpdate.length\n    }\n    return amountMessages\n  }\n\n  // Message loading if more than 100\n  getMoreMessages = async (dialog) => {\n    const currentMessages = this.getMessagesByDialogId(dialog.id)\n    const lastMessageDate = currentMessages[0]\n    const updateObj = Object.assign(dialog, { last_messages_for_fetch: lastMessageDate.date_sent })\n\n    const filter = {\n      chat_dialog_id: dialog.id,\n      date_sent: { lt: lastMessageDate.date_sent },\n      sort_desc: 'date_sent'\n    }\n\n    const moreHistoryFromServer = await ConnectyCube.chat.message.list(filter)\n\n    const messages = []\n    moreHistoryFromServer.items.forEach(elem => {\n      if (!elem.group_chat_alert_type) {\n        messages.push(new Message(elem, this.currentUser.id))\n      }\n    })\n\n    store.dispatch(updateDialog(updateObj))\n    const amountMessages = store.dispatch(lazyFetchMessages(dialog.id, messages))\n    return amountMessages.history.length\n  }\n\n\n  async sendMessage(dialog, messageText, attachments = false, scrollToBottom) {\n    const user = this.currentUser\n    const text = messageText.trim()\n    const date = Math.floor(Date.now() / 1000)\n    const recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(elem => elem != user.id)\n      : dialog.xmpp_room_jid\n\n    let msg = {\n      type: dialog.xmpp_type,\n      body: text,\n      extension: {\n        save_to_history: 1,\n        dialog_id: dialog.id,\n        sender_id: user.id,\n        date_sent: date,\n      },\n      // markable: 1\n    }\n\n    msg.id = this.messageUniqueId\n\n    // If send message as Attachment\n    if (attachments) {\n      return this.sendMessageAsAttachment(dialog, recipient_id, msg, attachments, scrollToBottom)\n    }\n\n    const message = new FakeMessage(msg)\n\n    const newObjFreez = Object.freeze(message)\n\n    await store.dispatch(pushMessage(newObjFreez, dialog.id))\n    scrollToBottom()\n    ConnectyCube.chat.send(recipient_id, msg)\n    store.dispatch(sortDialogs(newObjFreez))\n  }\n\n\n  sendMsgChatAlertOnCreate = async (dialog, message, alertType) => {\n    const date = Math.floor(Date.now() / 1000)\n    const recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(elem => elem != this.currentUser.id)\n      : dialog.xmpp_room_jid\n    const messageExtensions = {\n      date_sent: date,\n      save_to_history: 1,\n      dialog_id: dialog.id,\n      group_chat_alert_type: alertType,\n      sender_id: this.currentUser.id,\n    }\n    const msg = {\n      type: !dialog.xmpp_room_jid ? 'chat' : 'groupchat',\n      body: message,\n      extension: messageExtensions,\n    }\n    ConnectyCube.chat.send(recipient_id, msg)\n  }\n\n  sendChatAlertOnCreate(dialog) {\n    const message = 'Group is created'\n    this.sendMsgChatAlertOnCreate(dialog, message, GROUP_CHAT_ALERT_TYPE.CREATE)\n  }\n\n  async sendMessageAsAttachment(dialog, recipient_id, msg, attachments, scrollToBottom) {\n    //create fake data for render img\n    const url = URL.createObjectURL(attachments.file)\n    msg.extension.attachments = [{ url }]\n    msg.body = 'Image attachment'\n    const message = new FakeMessage(msg)\n    await store.dispatch(pushMessage(message, dialog.id))\n    scrollToBottom()\n\n    // create real data for attachment\n    const response = await this.uploadPhoto(attachments)\n    const newObjAttach = preparationAttachment(response)\n    msg.extension.attachments = [newObjAttach]\n    await ConnectyCube.chat.send(recipient_id, msg)\n    store.dispatch(sortDialogs(message))\n    return\n  }\n\n  async createPrivateDialog(userId) {\n    const dialogs = store.getState().dialogs\n    let dialog = null\n\n    dialogs.forEach(elem => {\n      if (elem.type === DIALOG_TYPE.PRIVATE && elem.occupants_ids.find(elem => elem === userId)) {\n        dialog = elem\n      }\n    })\n\n    if (!dialog) {\n      const params = {\n        type: DIALOG_TYPE.PRIVATE,\n        occupants_ids: userId,\n      }\n\n      const response = await ConnectyCube.chat.dialog.create(params)\n      dialog = new Dialog(response)\n      if (this.getUserFromReduxById(userId)) {\n        store.dispatch(addNewDialog(dialog))\n        return dialog\n      } else {\n        const usersInfo = await this.getUserFromServerById(userId)\n        usersInfo.user = new UserModel(usersInfo.user)\n        store.dispatch(fetchUsers([usersInfo.user]))\n        store.dispatch(addNewDialog(dialog))\n        return dialog\n      }\n    }\n\n    // If the user is already in the Redux\n    if (this.getUserFromReduxById(userId)) {\n      return dialog\n    } else {\n      const usersInfo = await this.getUserFromServerById(userId)\n      usersInfo.user = new UserModel(usersInfo.user)\n      store.dispatch(fetchUsers([usersInfo.user]))\n      return dialog\n    }\n  }\n\n\n  updateDialogsUnreadMessagesCount = (dialog) => {\n    const updateObj = Object.assign(dialog, { unread_messages_count: 0 })\n    store.dispatch(updateDialog(updateObj))\n    return true\n  }\n\n  async createPublicDialog(occupants_ids, groupName, img) {\n    const currentUser = this.currentUser\n    occupants_ids.unshift(currentUser.id)\n    const params = {\n      type: DIALOG_TYPE.GROUP,\n      occupants_ids,\n      name: groupName,\n    }\n    const image = img ? await this.uploadPhoto(img) : null\n    if (image) {\n      params.photo = image.uid\n    }\n    const dialog = await ConnectyCube.chat.dialog.create(params)\n    const newDialog = new Dialog(dialog)\n    store.dispatch(addNewDialog(newDialog))\n    return newDialog\n  }\n\n  async readAllMessages(dialogId) {\n    return ConnectyCube.chat.message.update(null, {\n      chat_dialog_id: dialogId,\n      read: 1\n    })\n  }\n\n  async readMessage(messageId, dialogId) {\n    this.onReadStatus(messageId, dialogId)\n    return ConnectyCube.chat.message.update(null, {\n      chat_dialog_id: dialogId,\n      read: 1\n    })\n  }\n\n  async onMessageListener(senderId, msg) {\n    const message = new Message(msg)\n    const user = this.currentUser\n    const dialog = this.getSelectedDialog()?.id\n\n    // If group chat alet\n    if (msg.extension.group_chat_alert_type) {\n      const dialogsFromServer = await ConnectyCube.chat.dialog.list()\n      const dialogs = dialogsFromServer.items.map(elem => {\n        return new Dialog(elem)\n      })\n      store.dispatch(fetchDialogs(dialogs))\n      return\n    }\n\n    if (senderId !== user.id) {\n      if (dialog === message.dialog_id) {\n        store.dispatch(sortDialogs(message))\n        this.readMessage(message.id, message.dialog_id)\n        this.sendReadStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id)\n      } else {\n        this.sendDeliveredStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id)\n        store.dispatch(sortDialogs(message, true))\n      }\n      store.dispatch(pushMessage(message, message.dialog_id))\n    }\n  }\n\n  // ConnectyCube listeners\n  onSentMessageListener(failedMessage, msg) {\n    console.warn('onSentMessageListener')\n    if (failedMessage || msg.extension.group_chat_alert_type) {\n      return\n    }\n    store.dispatch(updateMessages(msg.extension.dialog_id, msg.id, { send_state: STATUS_SENT }))\n  }\n\n  onDeliveredStatus(messageId, dialogId, userId) {\n    console.warn('onDeliveredStatus', messageId)\n    store.dispatch(updateMessages(dialogId, messageId, { send_state: STATUS_DELIVERED }))\n  }\n\n  onReadStatus(messageId, dialogId, userId) {\n    console.warn('onReadStatus', messageId)\n    store.dispatch(updateMessages(dialogId, messageId, { send_state: STATUS_READ }))\n  }\n\n\n\n  sendReadStatus(messageId, userId, dialogId) {\n    ConnectyCube.chat.sendReadStatus({ messageId, userId, dialogId })\n  }\n\n  sendDeliveredStatus(messageId, userId, dialogId) {\n    ConnectyCube.chat.sendDeliveredStatus({ messageId, userId, dialogId })\n  }\n\n  async getUsersList(ids) {\n    const usersList = await ConnectyCube.users.get({\n      per_page: 100,\n      filter: {\n        field: 'id', param: 'in', value: ids,\n      },\n    })\n\n    return usersList.items.map(elem => {\n      return new UserModel(elem.user)\n    })\n  }\n\n  async getUserFromServerById(id) {\n    return ConnectyCube.users.get(id)\n  }\n\n  setSelectDialog(dialog) {\n    store.dispatch(selectedDialog(dialog))\n  }\n\n  getSelectedDialog() {\n    return store.getState().selectedDialog\n  }\n\n  getDialogById(dialogId) {\n    return store.getState().dialogs.find(elem => elem.id === dialogId)\n  }\n\n  getMessagesByDialogId(dialogId) {\n    const result = store.getState().messages\n    return result[dialogId]\n  }\n\n  async uploadPhoto(file) {\n    return ConnectyCube.storage.createAndUpload(file)\n  }\n\n  get currentUser() {\n    return store.getState().currentUser.user\n  }\n\n  getUserFromReduxById(id) {\n    return store.getState().users[id]\n  }\n\n  get messageUniqueId() {\n    return ConnectyCube.chat.helpers.getBsonObjectId()\n  }\n}\n\n\nconst chatService = new ChatService()\n\nObject.freeze(chatService)\n\nexport default chatService\n\n"]},"metadata":{},"sourceType":"module"}