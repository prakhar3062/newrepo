{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport ConnectyCube from 'connectycube';\nimport Dialog from '../models/dialogs';\nimport { fetchDialogs, sortDialogs, updateDialog, addNewDialog } from '../actions/dialogs';\nimport { pushMessage, setMessages, lazyFetchMessages, updateMessages } from '../actions/messages';\nimport { preparationAttachment } from '../helpers/file';\nimport { selectedDialog } from '../actions/selectedDialog';\nimport { fetchUsers } from '../actions/users';\nimport store from '../store';\nimport { Message, FakeMessage } from '../models/message';\nimport UserModel from '../models/user';\nimport { DIALOG_TYPE } from '../helpers/constants';\nimport { STATUS_DELIVERED, STATUS_READ, STATUS_SENT, GROUP_CHAT_ALERT_TYPE } from '../models/message';\n\nvar ChatService = /*#__PURE__*/function () {\n  function ChatService() {\n    var _this = this;\n\n    _classCallCheck(this, ChatService);\n\n    _defineProperty(this, \"getMoreMessages\", /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dialog) {\n        var currentMessages, lastMessageDate, updateObj, filter, moreHistoryFromServer, messages, amountMessages;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                currentMessages = _this.getMessagesByDialogId(dialog.id);\n                lastMessageDate = currentMessages[0];\n                updateObj = Object.assign(dialog, {\n                  last_messages_for_fetch: lastMessageDate.date_sent\n                });\n                filter = {\n                  chat_dialog_id: dialog.id,\n                  date_sent: {\n                    lt: lastMessageDate.date_sent\n                  },\n                  sort_desc: 'date_sent'\n                };\n                _context.next = 6;\n                return ConnectyCube.chat.message.list(filter);\n\n              case 6:\n                moreHistoryFromServer = _context.sent;\n                messages = [];\n                moreHistoryFromServer.items.forEach(function (elem) {\n                  if (!elem.group_chat_alert_type) {\n                    messages.push(new Message(elem, _this.currentUser.id));\n                  }\n                });\n                store.dispatch(updateDialog(updateObj));\n                amountMessages = store.dispatch(lazyFetchMessages(dialog.id, messages));\n                return _context.abrupt(\"return\", amountMessages.history.length);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(this, \"sendMsgChatAlertOnCreate\", /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(dialog, message, alertType) {\n        var date, recipient_id, messageExtensions, msg;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                date = Math.floor(Date.now() / 1000);\n                recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(function (elem) {\n                  return elem != _this.currentUser.id;\n                }) : dialog.xmpp_room_jid;\n                messageExtensions = {\n                  date_sent: date,\n                  save_to_history: 1,\n                  dialog_id: dialog.id,\n                  group_chat_alert_type: alertType,\n                  sender_id: _this.currentUser.id\n                };\n                msg = {\n                  type: !dialog.xmpp_room_jid ? 'chat' : 'groupchat',\n                  body: message,\n                  extension: messageExtensions\n                };\n                ConnectyCube.chat.send(recipient_id, msg);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x2, _x3, _x4) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(this, \"updateDialogsUnreadMessagesCount\", function (dialog) {\n      var updateObj = Object.assign(dialog, {\n        unread_messages_count: 0\n      });\n      store.dispatch(updateDialog(updateObj));\n      return true;\n    });\n  }\n\n  _createClass(ChatService, [{\n    key: \"setUpListeners\",\n    value: function setUpListeners() {\n      ConnectyCube.chat.onMessageListener = this.onMessageListener.bind(this);\n      ConnectyCube.chat.onSentMessageCallback = this.onSentMessageListener.bind(this);\n      ConnectyCube.chat.onDeliveredStatusListener = this.onDeliveredStatus.bind(this);\n      ConnectyCube.chat.onReadStatusListener = this.onReadStatus.bind(this);\n    }\n  }, {\n    key: \"fetchDialogsFromServer\",\n    value: function () {\n      var _fetchDialogsFromServer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var dialogsFromServer, dialogs;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(store.getState().dialogs.length !== 0)) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", store.getState().dialogs);\n\n              case 2:\n                console.log('in fetch');\n                _context3.next = 5;\n                return ConnectyCube.chat.dialog.list();\n\n              case 5:\n                dialogsFromServer = _context3.sent;\n                // const currentUserId = this.currentUser\n                // let privatChatIdsUser = []\n                dialogs = dialogsFromServer.items.map(function (elem) {\n                  // if (elem.type === DIALOG_TYPE.PRIVATE) {\n                  //   elem.occupants_ids.forEach(elem => {\n                  //     elem !== currentUserId.id && privatChatIdsUser.push(elem)\n                  //   })\n                  // }\n                  return new Dialog(elem);\n                }); // if (privatChatIdsUser.length !== 0) {\n                //   const usersInfo = await this.getUsersList(privatChatIdsUser)\n                //   store.dispatch(fetchUsers(usersInfo))\n                // }\n\n                store.dispatch(fetchDialogs(dialogs));\n                return _context3.abrupt(\"return\", store.getState().dialogs);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function fetchDialogsFromServer() {\n        return _fetchDialogsFromServer.apply(this, arguments);\n      }\n\n      return fetchDialogsFromServer;\n    }()\n  }, {\n    key: \"getMessages\",\n    value: function () {\n      var _getMessages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(dialog) {\n        var _this2 = this;\n\n        var isAlredyUpdate, amountMessages, historyFromServer, messages, newObj, _messages, firstUnreadMsg;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                isAlredyUpdate = this.getMessagesByDialogId(dialog.id);\n                amountMessages = null; // If the first entry into the chat\n\n                if (!(!dialog.isAlreadyMessageFetch || dialog.unread_messages_count > 0 && !dialog.isAlreadyMessageFetch)) {\n                  _context4.next = 14;\n                  break;\n                }\n\n                _context4.next = 5;\n                return ConnectyCube.chat.message.list({\n                  chat_dialog_id: dialog.id,\n                  sort_desc: 'date_sent'\n                });\n\n              case 5:\n                historyFromServer = _context4.sent;\n                messages = [];\n                historyFromServer.items.forEach(function (elem) {\n                  if (!elem.group_chat_alert_type) {\n                    messages.push(new Message(elem, _this2.currentUser.id));\n                  }\n                });\n                newObj = Object.assign(dialog, {\n                  isAlreadyMessageFetch: true\n                });\n                this.updateDialogsUnreadMessagesCount(newObj);\n                store.dispatch(setMessages(dialog.id, messages));\n                amountMessages = messages.length;\n                _context4.next = 22;\n                break;\n\n              case 14:\n                if (!(dialog.unread_messages_count > 0)) {\n                  _context4.next = 21;\n                  break;\n                }\n\n                _messages = this.getMessagesByDialogId(dialog.id);\n                firstUnreadMsg = _messages[dialog.unread_messages_count - 1];\n                this.readAllMessages(dialog.id);\n                _context4.next = 20;\n                return this.sendReadStatus(firstUnreadMsg.id, firstUnreadMsg.sender_id, firstUnreadMsg.dialog_id);\n\n              case 20:\n                this.updateDialogsUnreadMessagesCount(dialog);\n\n              case 21:\n                amountMessages = isAlredyUpdate.length;\n\n              case 22:\n                return _context4.abrupt(\"return\", amountMessages);\n\n              case 23:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getMessages(_x5) {\n        return _getMessages.apply(this, arguments);\n      }\n\n      return getMessages;\n    }() // Message loading if more than 100\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(dialog, messageText) {\n        var attachments,\n            scrollToBottom,\n            user,\n            text,\n            date,\n            recipient_id,\n            msg,\n            message,\n            newObjFreez,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                attachments = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : false;\n                scrollToBottom = _args5.length > 3 ? _args5[3] : undefined;\n                user = this.currentUser;\n                text = messageText.trim();\n                date = Math.floor(Date.now() / 1000);\n                recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(function (elem) {\n                  return elem != user.id;\n                }) : dialog.xmpp_room_jid;\n                msg = {\n                  type: dialog.xmpp_type,\n                  body: text,\n                  extension: {\n                    save_to_history: 1,\n                    dialog_id: dialog.id,\n                    sender_id: user.id,\n                    date_sent: date\n                  } // markable: 1\n\n                };\n                msg.id = this.messageUniqueId; // If send message as Attachment\n\n                if (!attachments) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", this.sendMessageAsAttachment(dialog, recipient_id, msg, attachments, scrollToBottom));\n\n              case 10:\n                message = new FakeMessage(msg);\n                newObjFreez = Object.freeze(message);\n                _context5.next = 14;\n                return store.dispatch(pushMessage(newObjFreez, dialog.id));\n\n              case 14:\n                scrollToBottom();\n                ConnectyCube.chat.send(recipient_id, msg);\n                store.dispatch(sortDialogs(newObjFreez));\n\n              case 17:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function sendMessage(_x6, _x7) {\n        return _sendMessage.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n  }, {\n    key: \"sendChatAlertOnCreate\",\n    value: function sendChatAlertOnCreate(dialog) {\n      var message = 'Group is created';\n      this.sendMsgChatAlertOnCreate(dialog, message, GROUP_CHAT_ALERT_TYPE.CREATE);\n    }\n  }, {\n    key: \"sendMessageAsAttachment\",\n    value: function () {\n      var _sendMessageAsAttachment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(dialog, recipient_id, msg, attachments, scrollToBottom) {\n        var url, message, response, newObjAttach;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                //create fake data for render img\n                url = URL.createObjectURL(attachments.file);\n                msg.extension.attachments = [{\n                  url: url\n                }];\n                msg.body = 'Image attachment';\n                message = new FakeMessage(msg);\n                _context6.next = 6;\n                return store.dispatch(pushMessage(message, dialog.id));\n\n              case 6:\n                scrollToBottom(); // create real data for attachment\n\n                _context6.next = 9;\n                return this.uploadPhoto(attachments);\n\n              case 9:\n                response = _context6.sent;\n                newObjAttach = preparationAttachment(response);\n                msg.extension.attachments = [newObjAttach];\n                _context6.next = 14;\n                return ConnectyCube.chat.send(recipient_id, msg);\n\n              case 14:\n                store.dispatch(sortDialogs(message));\n                return _context6.abrupt(\"return\");\n\n              case 16:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function sendMessageAsAttachment(_x8, _x9, _x10, _x11, _x12) {\n        return _sendMessageAsAttachment.apply(this, arguments);\n      }\n\n      return sendMessageAsAttachment;\n    }()\n  }, {\n    key: \"createPrivateDialog\",\n    value: function () {\n      var _createPrivateDialog = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(userId) {\n        var dialogs, dialog, params, response, usersInfo, _usersInfo;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                dialogs = store.getState().dialogs;\n                dialog = null;\n                dialogs.forEach(function (elem) {\n                  if (elem.type === DIALOG_TYPE.PRIVATE && elem.occupants_ids.find(function (elem) {\n                    return elem === userId;\n                  })) {\n                    dialog = elem;\n                  }\n                });\n\n                if (dialog) {\n                  _context7.next = 21;\n                  break;\n                }\n\n                params = {\n                  type: DIALOG_TYPE.PRIVATE,\n                  occupants_ids: userId\n                };\n                _context7.next = 7;\n                return ConnectyCube.chat.dialog.create(params);\n\n              case 7:\n                response = _context7.sent;\n                dialog = new Dialog(response);\n\n                if (!this.getUserFromReduxById(userId)) {\n                  _context7.next = 14;\n                  break;\n                }\n\n                store.dispatch(addNewDialog(dialog));\n                return _context7.abrupt(\"return\", dialog);\n\n              case 14:\n                _context7.next = 16;\n                return this.getUserFromServerById(userId);\n\n              case 16:\n                usersInfo = _context7.sent;\n                usersInfo.user = new UserModel(usersInfo.user);\n                store.dispatch(fetchUsers([usersInfo.user]));\n                store.dispatch(addNewDialog(dialog));\n                return _context7.abrupt(\"return\", dialog);\n\n              case 21:\n                if (!this.getUserFromReduxById(userId)) {\n                  _context7.next = 25;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", dialog);\n\n              case 25:\n                _context7.next = 27;\n                return this.getUserFromServerById(userId);\n\n              case 27:\n                _usersInfo = _context7.sent;\n                _usersInfo.user = new UserModel(_usersInfo.user);\n                store.dispatch(fetchUsers([_usersInfo.user]));\n                return _context7.abrupt(\"return\", dialog);\n\n              case 31:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function createPrivateDialog(_x13) {\n        return _createPrivateDialog.apply(this, arguments);\n      }\n\n      return createPrivateDialog;\n    }()\n  }, {\n    key: \"createPublicDialog\",\n    value: function () {\n      var _createPublicDialog = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(occupants_ids, groupName, img) {\n        var currentUser, params, image, dialog, newDialog;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                currentUser = this.currentUser;\n                occupants_ids.unshift(currentUser.id);\n                params = {\n                  type: DIALOG_TYPE.GROUP,\n                  occupants_ids: occupants_ids,\n                  name: groupName\n                };\n\n                if (!img) {\n                  _context8.next = 9;\n                  break;\n                }\n\n                _context8.next = 6;\n                return this.uploadPhoto(img);\n\n              case 6:\n                _context8.t0 = _context8.sent;\n                _context8.next = 10;\n                break;\n\n              case 9:\n                _context8.t0 = null;\n\n              case 10:\n                image = _context8.t0;\n\n                if (image) {\n                  params.photo = image.uid;\n                }\n\n                _context8.next = 14;\n                return ConnectyCube.chat.dialog.create(params);\n\n              case 14:\n                dialog = _context8.sent;\n                newDialog = new Dialog(dialog);\n                store.dispatch(addNewDialog(newDialog));\n                return _context8.abrupt(\"return\", newDialog);\n\n              case 18:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function createPublicDialog(_x14, _x15, _x16) {\n        return _createPublicDialog.apply(this, arguments);\n      }\n\n      return createPublicDialog;\n    }()\n  }, {\n    key: \"readAllMessages\",\n    value: function () {\n      var _readAllMessages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(dialogId) {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                return _context9.abrupt(\"return\", ConnectyCube.chat.message.update(null, {\n                  chat_dialog_id: dialogId,\n                  read: 1\n                }));\n\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      function readAllMessages(_x17) {\n        return _readAllMessages.apply(this, arguments);\n      }\n\n      return readAllMessages;\n    }()\n  }, {\n    key: \"readMessage\",\n    value: function () {\n      var _readMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(messageId, dialogId) {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this.onReadStatus(messageId, dialogId);\n                return _context10.abrupt(\"return\", ConnectyCube.chat.message.update(null, {\n                  chat_dialog_id: dialogId,\n                  read: 1\n                }));\n\n              case 2:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function readMessage(_x18, _x19) {\n        return _readMessage.apply(this, arguments);\n      }\n\n      return readMessage;\n    }()\n  }, {\n    key: \"onMessageListener\",\n    value: function () {\n      var _onMessageListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(senderId, msg) {\n        var _this$getSelectedDial;\n\n        var message, user, dialog, dialogsFromServer, dialogs;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                message = new Message(msg);\n                user = this.currentUser;\n                dialog = (_this$getSelectedDial = this.getSelectedDialog()) === null || _this$getSelectedDial === void 0 ? void 0 : _this$getSelectedDial.id; // If group chat alet\n\n                if (!msg.extension.group_chat_alert_type) {\n                  _context11.next = 10;\n                  break;\n                }\n\n                _context11.next = 6;\n                return ConnectyCube.chat.dialog.list();\n\n              case 6:\n                dialogsFromServer = _context11.sent;\n                dialogs = dialogsFromServer.items.map(function (elem) {\n                  return new Dialog(elem);\n                });\n                store.dispatch(fetchDialogs(dialogs));\n                return _context11.abrupt(\"return\");\n\n              case 10:\n                if (senderId !== user.id) {\n                  if (dialog === message.dialog_id) {\n                    store.dispatch(sortDialogs(message));\n                    this.readMessage(message.id, message.dialog_id);\n                    this.sendReadStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id);\n                  } else {\n                    this.sendDeliveredStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id);\n                    store.dispatch(sortDialogs(message, true));\n                  }\n\n                  store.dispatch(pushMessage(message, message.dialog_id));\n                }\n\n              case 11:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function onMessageListener(_x20, _x21) {\n        return _onMessageListener.apply(this, arguments);\n      }\n\n      return onMessageListener;\n    }() // ConnectyCube listeners\n\n  }, {\n    key: \"onSentMessageListener\",\n    value: function onSentMessageListener(failedMessage, msg) {\n      console.warn('onSentMessageListener');\n\n      if (failedMessage || msg.extension.group_chat_alert_type) {\n        return;\n      }\n\n      store.dispatch(updateMessages(msg.extension.dialog_id, msg.id, {\n        send_state: STATUS_SENT\n      }));\n    }\n  }, {\n    key: \"onDeliveredStatus\",\n    value: function onDeliveredStatus(messageId, dialogId, userId) {\n      console.warn('onDeliveredStatus', messageId);\n      store.dispatch(updateMessages(dialogId, messageId, {\n        send_state: STATUS_DELIVERED\n      }));\n    }\n  }, {\n    key: \"onReadStatus\",\n    value: function onReadStatus(messageId, dialogId, userId) {\n      console.warn('onReadStatus', messageId);\n      store.dispatch(updateMessages(dialogId, messageId, {\n        send_state: STATUS_READ\n      }));\n    }\n  }, {\n    key: \"sendReadStatus\",\n    value: function sendReadStatus(messageId, userId, dialogId) {\n      ConnectyCube.chat.sendReadStatus({\n        messageId: messageId,\n        userId: userId,\n        dialogId: dialogId\n      });\n    }\n  }, {\n    key: \"sendDeliveredStatus\",\n    value: function sendDeliveredStatus(messageId, userId, dialogId) {\n      ConnectyCube.chat.sendDeliveredStatus({\n        messageId: messageId,\n        userId: userId,\n        dialogId: dialogId\n      });\n    }\n  }, {\n    key: \"getUsersList\",\n    value: function () {\n      var _getUsersList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(ids) {\n        var usersList;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return ConnectyCube.users.get({\n                  per_page: 100,\n                  filter: {\n                    field: 'id',\n                    param: 'in',\n                    value: ids\n                  }\n                });\n\n              case 2:\n                usersList = _context12.sent;\n                return _context12.abrupt(\"return\", usersList.items.map(function (elem) {\n                  return new UserModel(elem.user);\n                }));\n\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12);\n      }));\n\n      function getUsersList(_x22) {\n        return _getUsersList.apply(this, arguments);\n      }\n\n      return getUsersList;\n    }()\n  }, {\n    key: \"getUserFromServerById\",\n    value: function () {\n      var _getUserFromServerById = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(id) {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                return _context13.abrupt(\"return\", ConnectyCube.users.get(id));\n\n              case 1:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13);\n      }));\n\n      function getUserFromServerById(_x23) {\n        return _getUserFromServerById.apply(this, arguments);\n      }\n\n      return getUserFromServerById;\n    }()\n  }, {\n    key: \"setSelectDialog\",\n    value: function setSelectDialog(dialog) {\n      store.dispatch(selectedDialog(dialog));\n    }\n  }, {\n    key: \"getSelectedDialog\",\n    value: function getSelectedDialog() {\n      return store.getState().selectedDialog;\n    }\n  }, {\n    key: \"getDialogById\",\n    value: function getDialogById(dialogId) {\n      return store.getState().dialogs.find(function (elem) {\n        return elem.id === dialogId;\n      });\n    }\n  }, {\n    key: \"getMessagesByDialogId\",\n    value: function getMessagesByDialogId(dialogId) {\n      var result = store.getState().messages;\n      return result[dialogId];\n    }\n  }, {\n    key: \"uploadPhoto\",\n    value: function () {\n      var _uploadPhoto = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(file) {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                return _context14.abrupt(\"return\", ConnectyCube.storage.createAndUpload(file));\n\n              case 1:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14);\n      }));\n\n      function uploadPhoto(_x24) {\n        return _uploadPhoto.apply(this, arguments);\n      }\n\n      return uploadPhoto;\n    }()\n  }, {\n    key: \"getUserFromReduxById\",\n    value: function getUserFromReduxById(id) {\n      return store.getState().users[id];\n    }\n  }, {\n    key: \"currentUser\",\n    get: function get() {\n      return store.getState().currentUser.user;\n    }\n  }, {\n    key: \"messageUniqueId\",\n    get: function get() {\n      return ConnectyCube.chat.helpers.getBsonObjectId();\n    }\n  }]);\n\n  return ChatService;\n}();\n\nvar chatService = new ChatService();\nObject.freeze(chatService);\nexport default chatService;","map":{"version":3,"sources":["C:/Users/91911/Downloads/frontend/src/redux/services/chat-service.js"],"names":["ConnectyCube","Dialog","fetchDialogs","sortDialogs","updateDialog","addNewDialog","pushMessage","setMessages","lazyFetchMessages","updateMessages","preparationAttachment","selectedDialog","fetchUsers","store","Message","FakeMessage","UserModel","DIALOG_TYPE","STATUS_DELIVERED","STATUS_READ","STATUS_SENT","GROUP_CHAT_ALERT_TYPE","ChatService","dialog","currentMessages","getMessagesByDialogId","id","lastMessageDate","updateObj","Object","assign","last_messages_for_fetch","date_sent","filter","chat_dialog_id","lt","sort_desc","chat","message","list","moreHistoryFromServer","messages","items","forEach","elem","group_chat_alert_type","push","currentUser","dispatch","amountMessages","history","length","alertType","date","Math","floor","Date","now","recipient_id","type","PRIVATE","occupants_ids","find","xmpp_room_jid","messageExtensions","save_to_history","dialog_id","sender_id","msg","body","extension","send","unread_messages_count","onMessageListener","bind","onSentMessageCallback","onSentMessageListener","onDeliveredStatusListener","onDeliveredStatus","onReadStatusListener","onReadStatus","getState","dialogs","console","log","dialogsFromServer","map","isAlredyUpdate","isAlreadyMessageFetch","historyFromServer","newObj","updateDialogsUnreadMessagesCount","firstUnreadMsg","readAllMessages","sendReadStatus","messageText","attachments","scrollToBottom","user","text","trim","xmpp_type","messageUniqueId","sendMessageAsAttachment","newObjFreez","freeze","sendMsgChatAlertOnCreate","CREATE","url","URL","createObjectURL","file","uploadPhoto","response","newObjAttach","userId","params","create","getUserFromReduxById","getUserFromServerById","usersInfo","groupName","img","unshift","GROUP","name","image","photo","uid","newDialog","dialogId","update","read","messageId","senderId","getSelectedDialog","readMessage","message_id","sendDeliveredStatus","failedMessage","warn","send_state","ids","users","get","per_page","field","param","value","usersList","result","storage","createAndUpload","helpers","getBsonObjectId","chatService"],"mappings":"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","sourcesContent":["import ConnectyCube from 'connectycube'\nimport Dialog from '../models/dialogs'\nimport {\n  fetchDialogs,\n  sortDialogs,\n  updateDialog,\n  addNewDialog,\n} from '../actions/dialogs'\nimport {\n  pushMessage,\n  setMessages,\n  lazyFetchMessages,\n  updateMessages,\n} from '../actions/messages'\nimport { preparationAttachment } from '../helpers/file'\nimport { selectedDialog } from '../actions/selectedDialog'\nimport { fetchUsers } from '../actions/users'\nimport store from '../store'\nimport { Message, FakeMessage } from '../models/message'\nimport UserModel from '../models/user'\nimport { DIALOG_TYPE } from '../helpers/constants'\nimport {\n  STATUS_DELIVERED,\n  STATUS_READ,\n  STATUS_SENT,\n  GROUP_CHAT_ALERT_TYPE\n} from '../models/message'\n\nclass ChatService {\n\n  setUpListeners() {\n    ConnectyCube.chat.onMessageListener = this.onMessageListener.bind(this)\n    ConnectyCube.chat.onSentMessageCallback = this.onSentMessageListener.bind(this)\n    ConnectyCube.chat.onDeliveredStatusListener = this.onDeliveredStatus.bind(this)\n    ConnectyCube.chat.onReadStatusListener = this.onReadStatus.bind(this)\n  }\n\n  async fetchDialogsFromServer() {\n    if (store.getState().dialogs.length !== 0) {\n      return store.getState().dialogs\n    }\n\n    console.log('in fetch')\n   const dialogsFromServer =  await ConnectyCube.chat.dialog.list()\n    // const currentUserId = this.currentUser\n    // let privatChatIdsUser = []\n\n    const dialogs = dialogsFromServer.items.map(elem => {\n      // if (elem.type === DIALOG_TYPE.PRIVATE) {\n      //   elem.occupants_ids.forEach(elem => {\n      //     elem !== currentUserId.id && privatChatIdsUser.push(elem)\n      //   })\n      // }\n      return new Dialog(elem)\n    })\n\n    // if (privatChatIdsUser.length !== 0) {\n    //   const usersInfo = await this.getUsersList(privatChatIdsUser)\n    //   store.dispatch(fetchUsers(usersInfo))\n    // }\n\n    store.dispatch(fetchDialogs(dialogs))\n    return store.getState().dialogs\n  }\n\n  async getMessages(dialog) {\n    const isAlredyUpdate = this.getMessagesByDialogId(dialog.id)\n    let amountMessages = null\n\n    // If the first entry into the chat\n    if (!dialog.isAlreadyMessageFetch || dialog.unread_messages_count > 0 && !dialog.isAlreadyMessageFetch) {\n      const historyFromServer = await ConnectyCube.chat.message.list({\n        chat_dialog_id: dialog.id,\n        sort_desc: 'date_sent'\n      })\n\n      const messages = []\n      historyFromServer.items.forEach(elem => {\n        if (!elem.group_chat_alert_type) {\n          messages.push(new Message(elem, this.currentUser.id))\n        }\n      })\n\n      const newObj = Object.assign(dialog, { isAlreadyMessageFetch: true })\n      this.updateDialogsUnreadMessagesCount(newObj)\n      store.dispatch(setMessages(dialog.id, messages))\n      amountMessages = messages.length\n    } else {\n      // If the second entry into the chat\n      if (dialog.unread_messages_count > 0) {\n        const messages = this.getMessagesByDialogId(dialog.id)\n        const firstUnreadMsg = messages[dialog.unread_messages_count - 1]\n        this.readAllMessages(dialog.id)\n        await this.sendReadStatus(firstUnreadMsg.id, firstUnreadMsg.sender_id, firstUnreadMsg.dialog_id)\n        this.updateDialogsUnreadMessagesCount(dialog)\n      }\n      amountMessages = isAlredyUpdate.length\n    }\n    return amountMessages\n  }\n\n  // Message loading if more than 100\n  getMoreMessages = async (dialog) => {\n    const currentMessages = this.getMessagesByDialogId(dialog.id)\n    const lastMessageDate = currentMessages[0]\n    const updateObj = Object.assign(dialog, { last_messages_for_fetch: lastMessageDate.date_sent })\n\n    const filter = {\n      chat_dialog_id: dialog.id,\n      date_sent: { lt: lastMessageDate.date_sent },\n      sort_desc: 'date_sent'\n    }\n\n    const moreHistoryFromServer = await ConnectyCube.chat.message.list(filter)\n\n    const messages = []\n    moreHistoryFromServer.items.forEach(elem => {\n      if (!elem.group_chat_alert_type) {\n        messages.push(new Message(elem, this.currentUser.id))\n      }\n    })\n\n    store.dispatch(updateDialog(updateObj))\n    const amountMessages = store.dispatch(lazyFetchMessages(dialog.id, messages))\n    return amountMessages.history.length\n  }\n\n\n  async sendMessage(dialog, messageText, attachments = false, scrollToBottom) {\n    const user = this.currentUser\n    const text = messageText.trim()\n    const date = Math.floor(Date.now() / 1000)\n    const recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(elem => elem != user.id)\n      : dialog.xmpp_room_jid\n\n    let msg = {\n      type: dialog.xmpp_type,\n      body: text,\n      extension: {\n        save_to_history: 1,\n        dialog_id: dialog.id,\n        sender_id: user.id,\n        date_sent: date,\n      },\n      // markable: 1\n    }\n\n    msg.id = this.messageUniqueId\n\n    // If send message as Attachment\n    if (attachments) {\n      return this.sendMessageAsAttachment(dialog, recipient_id, msg, attachments, scrollToBottom)\n    }\n\n    const message = new FakeMessage(msg)\n\n    const newObjFreez = Object.freeze(message)\n\n    await store.dispatch(pushMessage(newObjFreez, dialog.id))\n    scrollToBottom()\n    ConnectyCube.chat.send(recipient_id, msg)\n    store.dispatch(sortDialogs(newObjFreez))\n  }\n\n\n  sendMsgChatAlertOnCreate = async (dialog, message, alertType) => {\n    const date = Math.floor(Date.now() / 1000)\n    const recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(elem => elem != this.currentUser.id)\n      : dialog.xmpp_room_jid\n    const messageExtensions = {\n      date_sent: date,\n      save_to_history: 1,\n      dialog_id: dialog.id,\n      group_chat_alert_type: alertType,\n      sender_id: this.currentUser.id,\n    }\n    const msg = {\n      type: !dialog.xmpp_room_jid ? 'chat' : 'groupchat',\n      body: message,\n      extension: messageExtensions,\n    }\n    ConnectyCube.chat.send(recipient_id, msg)\n  }\n\n  sendChatAlertOnCreate(dialog) {\n    const message = 'Group is created'\n    this.sendMsgChatAlertOnCreate(dialog, message, GROUP_CHAT_ALERT_TYPE.CREATE)\n  }\n\n  async sendMessageAsAttachment(dialog, recipient_id, msg, attachments, scrollToBottom) {\n    //create fake data for render img\n    const url = URL.createObjectURL(attachments.file)\n    msg.extension.attachments = [{ url }]\n    msg.body = 'Image attachment'\n    const message = new FakeMessage(msg)\n    await store.dispatch(pushMessage(message, dialog.id))\n    scrollToBottom()\n\n    // create real data for attachment\n    const response = await this.uploadPhoto(attachments)\n    const newObjAttach = preparationAttachment(response)\n    msg.extension.attachments = [newObjAttach]\n    await ConnectyCube.chat.send(recipient_id, msg)\n    store.dispatch(sortDialogs(message))\n    return\n  }\n\n  async createPrivateDialog(userId) {\n    const dialogs = store.getState().dialogs\n    let dialog = null\n\n    dialogs.forEach(elem => {\n      if (elem.type === DIALOG_TYPE.PRIVATE && elem.occupants_ids.find(elem => elem === userId)) {\n        dialog = elem\n      }\n    })\n\n    if (!dialog) {\n      const params = {\n        type: DIALOG_TYPE.PRIVATE,\n        occupants_ids: userId,\n      }\n\n      const response = await ConnectyCube.chat.dialog.create(params)\n      dialog = new Dialog(response)\n      if (this.getUserFromReduxById(userId)) {\n        store.dispatch(addNewDialog(dialog))\n        return dialog\n      } else {\n        const usersInfo = await this.getUserFromServerById(userId)\n        usersInfo.user = new UserModel(usersInfo.user)\n        store.dispatch(fetchUsers([usersInfo.user]))\n        store.dispatch(addNewDialog(dialog))\n        return dialog\n      }\n    }\n\n    // If the user is already in the Redux\n    if (this.getUserFromReduxById(userId)) {\n      return dialog\n    } else {\n      const usersInfo = await this.getUserFromServerById(userId)\n      usersInfo.user = new UserModel(usersInfo.user)\n      store.dispatch(fetchUsers([usersInfo.user]))\n      return dialog\n    }\n  }\n\n\n  updateDialogsUnreadMessagesCount = (dialog) => {\n    const updateObj = Object.assign(dialog, { unread_messages_count: 0 })\n    store.dispatch(updateDialog(updateObj))\n    return true\n  }\n\n  async createPublicDialog(occupants_ids, groupName, img) {\n    const currentUser = this.currentUser\n    occupants_ids.unshift(currentUser.id)\n    const params = {\n      type: DIALOG_TYPE.GROUP,\n      occupants_ids,\n      name: groupName,\n    }\n    const image = img ? await this.uploadPhoto(img) : null\n    if (image) {\n      params.photo = image.uid\n    }\n    const dialog = await ConnectyCube.chat.dialog.create(params)\n    const newDialog = new Dialog(dialog)\n    store.dispatch(addNewDialog(newDialog))\n    return newDialog\n  }\n\n  async readAllMessages(dialogId) {\n    return ConnectyCube.chat.message.update(null, {\n      chat_dialog_id: dialogId,\n      read: 1\n    })\n  }\n\n  async readMessage(messageId, dialogId) {\n    this.onReadStatus(messageId, dialogId)\n    return ConnectyCube.chat.message.update(null, {\n      chat_dialog_id: dialogId,\n      read: 1\n    })\n  }\n\n  async onMessageListener(senderId, msg) {\n    const message = new Message(msg)\n    const user = this.currentUser\n    const dialog = this.getSelectedDialog()?.id\n\n    // If group chat alet\n    if (msg.extension.group_chat_alert_type) {\n      const dialogsFromServer = await ConnectyCube.chat.dialog.list()\n      const dialogs = dialogsFromServer.items.map(elem => {\n        return new Dialog(elem)\n      })\n      store.dispatch(fetchDialogs(dialogs))\n      return\n    }\n\n    if (senderId !== user.id) {\n      if (dialog === message.dialog_id) {\n        store.dispatch(sortDialogs(message))\n        this.readMessage(message.id, message.dialog_id)\n        this.sendReadStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id)\n      } else {\n        this.sendDeliveredStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id)\n        store.dispatch(sortDialogs(message, true))\n      }\n      store.dispatch(pushMessage(message, message.dialog_id))\n    }\n  }\n\n  // ConnectyCube listeners\n  onSentMessageListener(failedMessage, msg) {\n    console.warn('onSentMessageListener')\n    if (failedMessage || msg.extension.group_chat_alert_type) {\n      return\n    }\n    store.dispatch(updateMessages(msg.extension.dialog_id, msg.id, { send_state: STATUS_SENT }))\n  }\n\n  onDeliveredStatus(messageId, dialogId, userId) {\n    console.warn('onDeliveredStatus', messageId)\n    store.dispatch(updateMessages(dialogId, messageId, { send_state: STATUS_DELIVERED }))\n  }\n\n  onReadStatus(messageId, dialogId, userId) {\n    console.warn('onReadStatus', messageId)\n    store.dispatch(updateMessages(dialogId, messageId, { send_state: STATUS_READ }))\n  }\n\n\n\n  sendReadStatus(messageId, userId, dialogId) {\n    ConnectyCube.chat.sendReadStatus({ messageId, userId, dialogId })\n  }\n\n  sendDeliveredStatus(messageId, userId, dialogId) {\n    ConnectyCube.chat.sendDeliveredStatus({ messageId, userId, dialogId })\n  }\n\n  async getUsersList(ids) {\n    const usersList = await ConnectyCube.users.get({\n      per_page: 100,\n      filter: {\n        field: 'id', param: 'in', value: ids,\n      },\n    })\n\n    return usersList.items.map(elem => {\n      return new UserModel(elem.user)\n    })\n  }\n\n  async getUserFromServerById(id) {\n    return ConnectyCube.users.get(id)\n  }\n\n  setSelectDialog(dialog) {\n    store.dispatch(selectedDialog(dialog))\n  }\n\n  getSelectedDialog() {\n    return store.getState().selectedDialog\n  }\n\n  getDialogById(dialogId) {\n    return store.getState().dialogs.find(elem => elem.id === dialogId)\n  }\n\n  getMessagesByDialogId(dialogId) {\n    const result = store.getState().messages\n    return result[dialogId]\n  }\n\n  async uploadPhoto(file) {\n    return ConnectyCube.storage.createAndUpload(file)\n  }\n\n  get currentUser() {\n    return store.getState().currentUser.user\n  }\n\n  getUserFromReduxById(id) {\n    return store.getState().users[id]\n  }\n\n  get messageUniqueId() {\n    return ConnectyCube.chat.helpers.getBsonObjectId()\n  }\n}\n\n\nconst chatService = new ChatService()\n\nObject.freeze(chatService)\n\nexport default chatService\n\n"]},"metadata":{},"sourceType":"module"}