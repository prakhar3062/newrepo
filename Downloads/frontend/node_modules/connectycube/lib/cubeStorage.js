const config = require('./cubeConfig')
const Utils = require('./cubeInternalUtils')

class StorageService {
  constructor(proxy) {
    this.proxy = proxy
  }

  list(params) {
    const ajaxParams = {
      type: 'GET',
      url: Utils.getUrl(config.urls.blobs),
      data: params
    }

    return this.proxy.ajax(ajaxParams)
  }

  create(params) {
    const ajaxParams = {
      type: 'POST',
      url: Utils.getUrl(config.urls.blobs),
      data: { blob: params }
    }

    return this.proxy.ajax(ajaxParams)
  }

  delete(id) {
    const ajaxParams = {
      type: 'DELETE',
      url: Utils.getUrl(config.urls.blobs, id),
      dataType: 'text'
    }

    return this.proxy.ajax(ajaxParams)
  }

  createAndUpload(params) {
    const createParams = {}
    let file
    let name
    let type
    let size
    let fileId
    let result

    const clonedParams = JSON.parse(JSON.stringify(params))

    clonedParams.file.data = '...'

    file = params.file
    name = params.name || file.name
    type = params.type || file.type
    size = params.size || file.size

    createParams.name = name
    createParams.content_type = type

    if (params.public) {
      createParams.public = params.public
    }

    return this.create(createParams)
      .then(({ blob }) => {
        const uri = parseUri(blob.blob_object_access.params)
        const uploadUrl = uri.protocol + '://' + uri.authority + uri.path

        const ajaxParams = { url: uploadUrl }
        const data = {}

        fileId = blob.id
        result = { ...blob, size }

        Object.keys(uri.queryKey).forEach(function (val) {
          data[val] = decodeURIComponent(uri.queryKey[val])
        })

        data.file = file
        ajaxParams.data = data

        return this.upload(ajaxParams)
      })
      .then(uploadResult => {
        const ajaxParams = {
          id: fileId,
          size: size
        }
        return this.markUploaded(ajaxParams)
      })
      .then(() => result)
  }

  upload(params) {
    const ajaxParams = {
      type: 'POST',
      url: params.url,
      dataType: 'text',
      contentType: false,
      data: params.data
    }

    return this.proxy.ajax(ajaxParams)
  }

  markUploaded(params) {
    const ajaxParams = {
      type: 'PUT',
      url: Utils.getUrl(config.urls.blobs, params.id + '/complete'),
      data: {
        size: params.size
      },
      dataType: 'text'
    }

    return this.proxy.ajax(ajaxParams)
  }

  getInfo(id) {
    const ajaxParams = {
      url: Utils.getUrl(config.urls.blobs, id)
    }

    return this.proxy.ajax(ajaxParams)
  }

  getFile(uid) {
    const ajaxParams = {
      url: Utils.getUrl(config.urls.blobs, uid)
    }

    return this.proxy.ajax(ajaxParams)
  }

  update(params) {
    const data = {}
    data.blob = {}
    if (typeof params.name !== 'undefined') {
      data.blob.name = params.name
    }

    const ajaxParams = {
      url: Utils.getUrl(config.urls.blobs, params.id),
      data: data
    }

    return this.proxy.ajax(ajaxParams)
  }

  privateUrl(fileUID) {
    return (
      'https://' +
      config.endpoints.api +
      '/blobs/' +
      fileUID +
      '?token=' +
      this.proxy.getSession().token
    )
  }

  publicUrl(fileUID) {
    return 'https://' + config.endpoints.api + '/blobs/' + fileUID
  }
}

module.exports = StorageService

// parseUri 1.2.2
// (c) Steven Levithan <stevenlevithan.com>
// MIT License
// http://blog.stevenlevithan.com/archives/parseuri
function parseUri(str) {
  const o = parseUri.options
  const m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str)

  const uri = {}
  let i = 14

  while (i--) {
    uri[o.key[i]] = m[i] || ''
  }

  uri[o.q.name] = {}
  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
    if ($1) {
      uri[o.q.name][$1] = $2
    }
  })

  return uri
}

parseUri.options = {
  strictMode: false,
  key: [
    'source',
    'protocol',
    'authority',
    'userInfo',
    'user',
    'password',
    'host',
    'port',
    'relative',
    'path',
    'directory',
    'file',
    'query',
    'anchor'
  ],
  q: {
    name: 'queryKey',
    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
  },
  parser: {
    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
}
